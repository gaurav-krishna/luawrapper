// src/LuaEngine.cpp
#include "lua_wrapper/LuaEngine.hpp"
#include <fstream>
#include <sstream>
#include <iostream>
#include <type_traits>

namespace lua_wrapper {

namespace {

// Helper traits to check if a type is callable with Lua state
template<typename T>
struct is_lua_callable {
    using type = typename std::remove_reference<T>::type;
    static constexpr bool value = std::is_same<lua_CFunction, type>::value || 
        std::is_same<std::function<int(lua_State*)>, type>::value;
};

// Helper function to handle the Lua->C++ function call
int function_dispatcher(lua_State* L) {
    // Get the function object from userdata
    auto* fn = static_cast<std::function<int(lua_State*)>*>(lua_touserdata(L, lua_upvalueindex(1)));
    if (!fn) {
        luaL_error(L, "Invalid function object");
        return 0;
    }
    return (*fn)(L);
}

} // anonymous namespace

// Constructor - initializes new Lua state
LuaEngine::LuaEngine() 
    : m_state(luaL_newstate()) {
    if (!m_state) {
        throw LuaException("Failed to create Lua state");
    }
    luaL_openlibs(m_state.get());
}

// Execute a Lua script from file
void LuaEngine::executeFile(const std::string& path) {
    std::ifstream file(path);
    if (!file) {
        throw LuaException("Unable to open Lua file: " + path);
    }
    std::stringstream buffer;
    buffer << file.rdbuf();
    
    doLoadString(buffer.str());
    doCallFunction(0, 0);
}

// Load a Lua script string
bool LuaEngine::doLoadString(const std::string& script) {
    int rc = luaL_loadstring(m_state.get(), script.c_str());
    if (rc != LUA_OK) {
        std::string err = lua_tostring(m_state.get(), -1);
        lua_pop(m_state.get(), 1);
        throw LuaException("Lua load error: " + err);
    }
    return true;
}

// Call a Lua function
bool LuaEngine::doCallFunction(int nargs, int nresults) {
    int rc = lua_pcall(m_state.get(), nargs, nresults, 0);
    if (rc != LUA_OK) {
        std::string err = lua_tostring(m_state.get(), -1);
        lua_pop(m_state.get(), 1);
        throw LuaException("Lua runtime error: " + err);
    }
    return true;
}

// Get a global function from Lua state
void LuaEngine::doGetGlobal(const std::string& name) {
    lua_getglobal(m_state.get(), name.c_str());
    if (!lua_isfunction(m_state.get(), -1)) {
        lua_pop(m_state.get(), 1);
        throw LuaException("Global '" + name + "' is not a function");
    }
}

// Register a raw C++ function in Lua
void LuaEngine::registerFunctionImplRaw(const std::string& name, void* funcPtr,
                                      const std::type_info* retType,
                                      const std::vector<const std::type_info*>& argTypes) {
    // Create the function object in Lua-owned memory
    auto* fnPtr = reinterpret_cast<std::function<int(lua_State*)>*>(funcPtr);
    void* userData = lua_newuserdata(m_state.get(), sizeof(*fnPtr));
    new (userData) std::function<int(lua_State*)>(*fnPtr);
    
    // Set up the C closure with our dispatcher and function object
    lua_pushcclosure(m_state.get(), function_dispatcher, 1);
    
    // Set it as a global function
    lua_setglobal(m_state.get(), name.c_str());
}

} // namespace lua_wrapper
